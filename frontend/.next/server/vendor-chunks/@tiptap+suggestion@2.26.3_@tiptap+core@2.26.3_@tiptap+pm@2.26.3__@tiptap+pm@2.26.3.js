"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap+suggestion@2.26.3_@tiptap+core@2.26.3_@tiptap+pm@2.26.3__@tiptap+pm@2.26.3";
exports.ids = ["vendor-chunks/@tiptap+suggestion@2.26.3_@tiptap+core@2.26.3_@tiptap+pm@2.26.3__@tiptap+pm@2.26.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@tiptap+suggestion@2.26.3_@tiptap+core@2.26.3_@tiptap+pm@2.26.3__@tiptap+pm@2.26.3/node_modules/@tiptap/suggestion/dist/index.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tiptap+suggestion@2.26.3_@tiptap+core@2.26.3_@tiptap+pm@2.26.3__@tiptap+pm@2.26.3/node_modules/@tiptap/suggestion/dist/index.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Suggestion: () => (/* binding */ Suggestion),\n/* harmony export */   SuggestionPluginKey: () => (/* binding */ SuggestionPluginKey),\n/* harmony export */   \"default\": () => (/* binding */ Suggestion),\n/* harmony export */   findSuggestionMatch: () => (/* binding */ findSuggestionMatch)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/.pnpm/@tiptap+pm@2.26.3/node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/.pnpm/@tiptap+pm@2.26.3/node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/.pnpm/@tiptap+core@2.26.3_@tiptap+pm@2.26.3/node_modules/@tiptap/core/dist/index.js\");\n\n\n\n\nfunction findSuggestionMatch(config) {\n    var _a;\n    const { char, allowSpaces: allowSpacesOption, allowToIncludeChar, allowedPrefixes, startOfLine, $position, } = config;\n    const allowSpaces = allowSpacesOption && !allowToIncludeChar;\n    const escapedChar = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.escapeForRegEx)(char);\n    const suffix = new RegExp(`\\\\s${escapedChar}$`);\n    const prefix = startOfLine ? '^' : '';\n    const finalEscapedChar = allowToIncludeChar ? '' : escapedChar;\n    const regexp = allowSpaces\n        ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${finalEscapedChar}|$)`, 'gm')\n        : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${finalEscapedChar}]*`, 'gm');\n    const text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;\n    if (!text) {\n        return null;\n    }\n    const textFrom = $position.pos - text.length;\n    const match = Array.from(text.matchAll(regexp)).pop();\n    if (!match || match.input === undefined || match.index === undefined) {\n        return null;\n    }\n    // JavaScript doesn't have lookbehinds. This hacks a check that first character\n    // is a space or the start of the line\n    const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n    const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join('')}\\0]?$`).test(matchPrefix);\n    if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\n        return null;\n    }\n    // The absolute position of the match in the document\n    const from = textFrom + match.index;\n    let to = from + match[0].length;\n    // Edge case handling; if spaces are allowed and we're directly in between\n    // two triggers\n    if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n        match[0] += ' ';\n        to += 1;\n    }\n    // If the $position is located within the matched substring, return that range\n    if (from < $position.pos && to >= $position.pos) {\n        return {\n            range: {\n                from,\n                to,\n            },\n            query: match[0].slice(char.length),\n            text: match[0],\n        };\n    }\n    return null;\n}\n\nconst SuggestionPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('suggestion');\n/**\n * This utility allows you to create suggestions.\n * @see https://tiptap.dev/api/utilities/suggestion\n */\nfunction Suggestion({ pluginKey = SuggestionPluginKey, editor, char = '@', allowSpaces = false, allowToIncludeChar = false, allowedPrefixes = [' '], startOfLine = false, decorationTag = 'span', decorationClass = 'suggestion', decorationContent = '', decorationEmptyClass = 'is-empty', command = () => null, items = () => [], render = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch, }) {\n    let props;\n    const renderer = render === null || render === void 0 ? void 0 : render();\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey,\n        view() {\n            return {\n                update: async (view, prevState) => {\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);\n                    const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);\n                    // See how the state changed\n                    const moved = prev.active && next.active && prev.range.from !== next.range.from;\n                    const started = !prev.active && next.active;\n                    const stopped = prev.active && !next.active;\n                    const changed = !started && !stopped && prev.query !== next.query;\n                    const handleStart = started || (moved && changed);\n                    const handleChange = changed || moved;\n                    const handleExit = stopped || (moved && changed);\n                    // Cancel when suggestion isn't active\n                    if (!handleStart && !handleChange && !handleExit) {\n                        return;\n                    }\n                    const state = handleExit && !handleStart ? prev : next;\n                    const decorationNode = view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`);\n                    props = {\n                        editor,\n                        range: state.range,\n                        query: state.query,\n                        text: state.text,\n                        items: [],\n                        command: commandProps => {\n                            return command({\n                                editor,\n                                range: state.range,\n                                props: commandProps,\n                            });\n                        },\n                        decorationNode,\n                        // virtual node for popper.js or tippy.js\n                        // this can be used for building popups without a DOM node\n                        clientRect: decorationNode\n                            ? () => {\n                                var _a;\n                                // because of `items` can be asynchrounous weâ€™ll search for the current decoration node\n                                const { decorationId } = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state); // eslint-disable-line\n                                const currentDecorationNode = view.dom.querySelector(`[data-decoration-id=\"${decorationId}\"]`);\n                                return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;\n                            }\n                            : null,\n                    };\n                    if (handleStart) {\n                        (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);\n                    }\n                    if (handleChange) {\n                        (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);\n                    }\n                    if (handleChange || handleStart) {\n                        props.items = await items({\n                            editor,\n                            query: state.query,\n                        });\n                    }\n                    if (handleExit) {\n                        (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);\n                    }\n                    if (handleChange) {\n                        (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);\n                    }\n                    if (handleStart) {\n                        (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);\n                    }\n                },\n                destroy: () => {\n                    var _a;\n                    if (!props) {\n                        return;\n                    }\n                    (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);\n                },\n            };\n        },\n        state: {\n            // Initialize the plugin's internal state.\n            init() {\n                const state = {\n                    active: false,\n                    range: {\n                        from: 0,\n                        to: 0,\n                    },\n                    query: null,\n                    text: null,\n                    composing: false,\n                };\n                return state;\n            },\n            // Apply changes to the plugin state from a view transaction.\n            apply(transaction, prev, _oldState, state) {\n                const { isEditable } = editor;\n                const { composing } = editor.view;\n                const { selection } = transaction;\n                const { empty, from } = selection;\n                const next = { ...prev };\n                next.composing = composing;\n                // We can only be suggesting if the view is editable, and:\n                //   * there is no selection, or\n                //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\n                if (isEditable && (empty || editor.view.composing)) {\n                    // Reset active state if we just left the previous suggestion range\n                    if ((from < prev.range.from || from > prev.range.to)\n                        && !composing\n                        && !prev.composing) {\n                        next.active = false;\n                    }\n                    // Try to match against where our cursor currently is\n                    const match = findSuggestionMatch$1({\n                        char,\n                        allowSpaces,\n                        allowToIncludeChar,\n                        allowedPrefixes,\n                        startOfLine,\n                        $position: selection.$from,\n                    });\n                    const decorationId = `id_${Math.floor(Math.random() * 0xffffffff)}`;\n                    // If we found a match, update the current state to show it\n                    if (match\n                        && allow({\n                            editor,\n                            state,\n                            range: match.range,\n                            isActive: prev.active,\n                        })) {\n                        next.active = true;\n                        next.decorationId = prev.decorationId\n                            ? prev.decorationId\n                            : decorationId;\n                        next.range = match.range;\n                        next.query = match.query;\n                        next.text = match.text;\n                    }\n                    else {\n                        next.active = false;\n                    }\n                }\n                else {\n                    next.active = false;\n                }\n                // Make sure to empty the range if suggestion is inactive\n                if (!next.active) {\n                    next.decorationId = null;\n                    next.range = { from: 0, to: 0 };\n                    next.query = null;\n                    next.text = null;\n                }\n                return next;\n            },\n        },\n        props: {\n            // Call the keydown hook if suggestion is active.\n            handleKeyDown(view, event) {\n                var _a;\n                const { active, range } = plugin.getState(view.state);\n                if (!active) {\n                    return false;\n                }\n                return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;\n            },\n            // Setup decorator on the currently active suggestion.\n            decorations(state) {\n                const { active, range, decorationId, query, } = plugin.getState(state);\n                if (!active) {\n                    return null;\n                }\n                const isEmpty = !(query === null || query === void 0 ? void 0 : query.length);\n                const classNames = [decorationClass];\n                if (isEmpty) {\n                    classNames.push(decorationEmptyClass);\n                }\n                return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.create(state.doc, [\n                    _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.inline(range.from, range.to, {\n                        nodeName: decorationTag,\n                        class: classNames.join(' '),\n                        'data-decoration-id': decorationId,\n                        'data-decoration-content': decorationContent,\n                    }),\n                ]);\n            },\n        },\n    });\n    return plugin;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRpcHRhcCtzdWdnZXN0aW9uQDIuMjYuM19AdGlwdGFwK2NvcmVAMi4yNi4zX0B0aXB0YXArcG1AMi4yNi4zX19AdGlwdGFwK3BtQDIuMjYuMy9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdWdnZXN0aW9uL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxRDtBQUNPO0FBQ2Q7O0FBRTlDO0FBQ0E7QUFDQSxZQUFZLHFHQUFxRztBQUNqSDtBQUNBLHdCQUF3Qiw0REFBYztBQUN0QyxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxFQUFFLFlBQVksV0FBVyxpQkFBaUI7QUFDekUsd0JBQXdCLE9BQU8sUUFBUSxZQUFZLE9BQU8saUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyRkFBMkY7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx1REFBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpVUFBaVUsMEZBQTBGO0FBQ2piO0FBQ0E7QUFDQSx1QkFBdUIsb0RBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixtQkFBbUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZSxrRkFBa0Y7QUFDekksNkdBQTZHLGFBQWE7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQyx3QkFBd0IsWUFBWTtBQUNwQyx3QkFBd0IsWUFBWTtBQUNwQyx3QkFBd0IsY0FBYztBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsK0NBQStDLHVDQUF1QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSwrSkFBK0osb0JBQW9CO0FBQ25MLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBEQUFhO0FBQ3BDLG9CQUFvQix1REFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRXVGO0FBQ3ZGIiwic291cmNlcyI6WyIvcm9vdC90aGUxMS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQHRpcHRhcCtzdWdnZXN0aW9uQDIuMjYuM19AdGlwdGFwK2NvcmVAMi4yNi4zX0B0aXB0YXArcG1AMi4yNi4zX19AdGlwdGFwK3BtQDIuMjYuMy9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdWdnZXN0aW9uL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGx1Z2luS2V5LCBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB7IERlY29yYXRpb25TZXQsIERlY29yYXRpb24gfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnO1xuaW1wb3J0IHsgZXNjYXBlRm9yUmVnRXggfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG5mdW5jdGlvbiBmaW5kU3VnZ2VzdGlvbk1hdGNoKGNvbmZpZykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGNoYXIsIGFsbG93U3BhY2VzOiBhbGxvd1NwYWNlc09wdGlvbiwgYWxsb3dUb0luY2x1ZGVDaGFyLCBhbGxvd2VkUHJlZml4ZXMsIHN0YXJ0T2ZMaW5lLCAkcG9zaXRpb24sIH0gPSBjb25maWc7XG4gICAgY29uc3QgYWxsb3dTcGFjZXMgPSBhbGxvd1NwYWNlc09wdGlvbiAmJiAhYWxsb3dUb0luY2x1ZGVDaGFyO1xuICAgIGNvbnN0IGVzY2FwZWRDaGFyID0gZXNjYXBlRm9yUmVnRXgoY2hhcik7XG4gICAgY29uc3Qgc3VmZml4ID0gbmV3IFJlZ0V4cChgXFxcXHMke2VzY2FwZWRDaGFyfSRgKTtcbiAgICBjb25zdCBwcmVmaXggPSBzdGFydE9mTGluZSA/ICdeJyA6ICcnO1xuICAgIGNvbnN0IGZpbmFsRXNjYXBlZENoYXIgPSBhbGxvd1RvSW5jbHVkZUNoYXIgPyAnJyA6IGVzY2FwZWRDaGFyO1xuICAgIGNvbnN0IHJlZ2V4cCA9IGFsbG93U3BhY2VzXG4gICAgICAgID8gbmV3IFJlZ0V4cChgJHtwcmVmaXh9JHtlc2NhcGVkQ2hhcn0uKj8oPz1cXFxccyR7ZmluYWxFc2NhcGVkQ2hhcn18JClgLCAnZ20nKVxuICAgICAgICA6IG5ldyBSZWdFeHAoYCR7cHJlZml4fSg/Ol4pPyR7ZXNjYXBlZENoYXJ9W15cXFxccyR7ZmluYWxFc2NhcGVkQ2hhcn1dKmAsICdnbScpO1xuICAgIGNvbnN0IHRleHQgPSAoKF9hID0gJHBvc2l0aW9uLm5vZGVCZWZvcmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1RleHQpICYmICRwb3NpdGlvbi5ub2RlQmVmb3JlLnRleHQ7XG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0RnJvbSA9ICRwb3NpdGlvbi5wb3MgLSB0ZXh0Lmxlbmd0aDtcbiAgICBjb25zdCBtYXRjaCA9IEFycmF5LmZyb20odGV4dC5tYXRjaEFsbChyZWdleHApKS5wb3AoKTtcbiAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmlucHV0ID09PSB1bmRlZmluZWQgfHwgbWF0Y2guaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gSmF2YVNjcmlwdCBkb2Vzbid0IGhhdmUgbG9va2JlaGluZHMuIFRoaXMgaGFja3MgYSBjaGVjayB0aGF0IGZpcnN0IGNoYXJhY3RlclxuICAgIC8vIGlzIGEgc3BhY2Ugb3IgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXG4gICAgY29uc3QgbWF0Y2hQcmVmaXggPSBtYXRjaC5pbnB1dC5zbGljZShNYXRoLm1heCgwLCBtYXRjaC5pbmRleCAtIDEpLCBtYXRjaC5pbmRleCk7XG4gICAgY29uc3QgbWF0Y2hQcmVmaXhJc0FsbG93ZWQgPSBuZXcgUmVnRXhwKGBeWyR7YWxsb3dlZFByZWZpeGVzID09PSBudWxsIHx8IGFsbG93ZWRQcmVmaXhlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWxsb3dlZFByZWZpeGVzLmpvaW4oJycpfVxcMF0/JGApLnRlc3QobWF0Y2hQcmVmaXgpO1xuICAgIGlmIChhbGxvd2VkUHJlZml4ZXMgIT09IG51bGwgJiYgIW1hdGNoUHJlZml4SXNBbGxvd2VkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIG1hdGNoIGluIHRoZSBkb2N1bWVudFxuICAgIGNvbnN0IGZyb20gPSB0ZXh0RnJvbSArIG1hdGNoLmluZGV4O1xuICAgIGxldCB0byA9IGZyb20gKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgLy8gRWRnZSBjYXNlIGhhbmRsaW5nOyBpZiBzcGFjZXMgYXJlIGFsbG93ZWQgYW5kIHdlJ3JlIGRpcmVjdGx5IGluIGJldHdlZW5cbiAgICAvLyB0d28gdHJpZ2dlcnNcbiAgICBpZiAoYWxsb3dTcGFjZXMgJiYgc3VmZml4LnRlc3QodGV4dC5zbGljZSh0byAtIDEsIHRvICsgMSkpKSB7XG4gICAgICAgIG1hdGNoWzBdICs9ICcgJztcbiAgICAgICAgdG8gKz0gMTtcbiAgICB9XG4gICAgLy8gSWYgdGhlICRwb3NpdGlvbiBpcyBsb2NhdGVkIHdpdGhpbiB0aGUgbWF0Y2hlZCBzdWJzdHJpbmcsIHJldHVybiB0aGF0IHJhbmdlXG4gICAgaWYgKGZyb20gPCAkcG9zaXRpb24ucG9zICYmIHRvID49ICRwb3NpdGlvbi5wb3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBxdWVyeTogbWF0Y2hbMF0uc2xpY2UoY2hhci5sZW5ndGgpLFxuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBTdWdnZXN0aW9uUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgnc3VnZ2VzdGlvbicpO1xuLyoqXG4gKiBUaGlzIHV0aWxpdHkgYWxsb3dzIHlvdSB0byBjcmVhdGUgc3VnZ2VzdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvdXRpbGl0aWVzL3N1Z2dlc3Rpb25cbiAqL1xuZnVuY3Rpb24gU3VnZ2VzdGlvbih7IHBsdWdpbktleSA9IFN1Z2dlc3Rpb25QbHVnaW5LZXksIGVkaXRvciwgY2hhciA9ICdAJywgYWxsb3dTcGFjZXMgPSBmYWxzZSwgYWxsb3dUb0luY2x1ZGVDaGFyID0gZmFsc2UsIGFsbG93ZWRQcmVmaXhlcyA9IFsnICddLCBzdGFydE9mTGluZSA9IGZhbHNlLCBkZWNvcmF0aW9uVGFnID0gJ3NwYW4nLCBkZWNvcmF0aW9uQ2xhc3MgPSAnc3VnZ2VzdGlvbicsIGRlY29yYXRpb25Db250ZW50ID0gJycsIGRlY29yYXRpb25FbXB0eUNsYXNzID0gJ2lzLWVtcHR5JywgY29tbWFuZCA9ICgpID0+IG51bGwsIGl0ZW1zID0gKCkgPT4gW10sIHJlbmRlciA9ICgpID0+ICh7fSksIGFsbG93ID0gKCkgPT4gdHJ1ZSwgZmluZFN1Z2dlc3Rpb25NYXRjaDogZmluZFN1Z2dlc3Rpb25NYXRjaCQxID0gZmluZFN1Z2dlc3Rpb25NYXRjaCwgfSkge1xuICAgIGxldCBwcm9wcztcbiAgICBjb25zdCByZW5kZXJlciA9IHJlbmRlciA9PT0gbnVsbCB8fCByZW5kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcigpO1xuICAgIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IHBsdWdpbktleSxcbiAgICAgICAgdmlldygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBhc3luYyAodmlldywgcHJldlN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IChfYSA9IHRoaXMua2V5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdGUocHJldlN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IChfYiA9IHRoaXMua2V5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBob3cgdGhlIHN0YXRlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW92ZWQgPSBwcmV2LmFjdGl2ZSAmJiBuZXh0LmFjdGl2ZSAmJiBwcmV2LnJhbmdlLmZyb20gIT09IG5leHQucmFuZ2UuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRlZCA9ICFwcmV2LmFjdGl2ZSAmJiBuZXh0LmFjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcHBlZCA9IHByZXYuYWN0aXZlICYmICFuZXh0LmFjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlZCA9ICFzdGFydGVkICYmICFzdG9wcGVkICYmIHByZXYucXVlcnkgIT09IG5leHQucXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZVN0YXJ0ID0gc3RhcnRlZCB8fCAobW92ZWQgJiYgY2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IGNoYW5nZWQgfHwgbW92ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUV4aXQgPSBzdG9wcGVkIHx8IChtb3ZlZCAmJiBjaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIHdoZW4gc3VnZ2VzdGlvbiBpc24ndCBhY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVTdGFydCAmJiAhaGFuZGxlQ2hhbmdlICYmICFoYW5kbGVFeGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBoYW5kbGVFeGl0ICYmICFoYW5kbGVTdGFydCA/IHByZXYgOiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uTm9kZSA9IHZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke3N0YXRlLmRlY29yYXRpb25JZH1cIl1gKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogc3RhdGUucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdGF0ZS50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZFByb3BzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLnJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogY29tbWFuZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25Ob2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmlydHVhbCBub2RlIGZvciBwb3BwZXIuanMgb3IgdGlwcHkuanNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIGJlIHVzZWQgZm9yIGJ1aWxkaW5nIHBvcHVwcyB3aXRob3V0IGEgRE9NIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFJlY3Q6IGRlY29yYXRpb25Ob2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBvZiBgaXRlbXNgIGNhbiBiZSBhc3luY2hyb3Vub3VzIHdl4oCZbGwgc2VhcmNoIGZvciB0aGUgY3VycmVudCBkZWNvcmF0aW9uIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWNvcmF0aW9uSWQgfSA9IChfYSA9IHRoaXMua2V5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdGUoZWRpdG9yLnN0YXRlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RGVjb3JhdGlvbk5vZGUgPSB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHtkZWNvcmF0aW9uSWR9XCJdYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3VycmVudERlY29yYXRpb25Ob2RlID09PSBudWxsIHx8IGN1cnJlbnREZWNvcmF0aW9uTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudERlY29yYXRpb25Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uQmVmb3JlU3RhcnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHJlbmRlcmVyLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9kID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uQmVmb3JlVXBkYXRlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChyZW5kZXJlciwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVDaGFuZ2UgfHwgaGFuZGxlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLml0ZW1zID0gYXdhaXQgaXRlbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogc3RhdGUucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlRXhpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9lID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uRXhpdCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwocmVuZGVyZXIsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2YgPSByZW5kZXJlciA9PT0gbnVsbCB8fCByZW5kZXJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyZXIub25VcGRhdGUpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKHJlbmRlcmVyLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2cgPSByZW5kZXJlciA9PT0gbnVsbCB8fCByZW5kZXJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyZXIub25TdGFydCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmNhbGwocmVuZGVyZXIsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX2EgPSByZW5kZXJlciA9PT0gbnVsbCB8fCByZW5kZXJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyZXIub25FeGl0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChyZW5kZXJlciwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcGx1Z2luJ3MgaW50ZXJuYWwgc3RhdGUuXG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBBcHBseSBjaGFuZ2VzIHRvIHRoZSBwbHVnaW4gc3RhdGUgZnJvbSBhIHZpZXcgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICBhcHBseSh0cmFuc2FjdGlvbiwgcHJldiwgX29sZFN0YXRlLCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gZWRpdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29tcG9zaW5nIH0gPSBlZGl0b3IudmlldztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB7IC4uLnByZXYgfTtcbiAgICAgICAgICAgICAgICBuZXh0LmNvbXBvc2luZyA9IGNvbXBvc2luZztcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gb25seSBiZSBzdWdnZXN0aW5nIGlmIHRoZSB2aWV3IGlzIGVkaXRhYmxlLCBhbmQ6XG4gICAgICAgICAgICAgICAgLy8gICAqIHRoZXJlIGlzIG5vIHNlbGVjdGlvbiwgb3JcbiAgICAgICAgICAgICAgICAvLyAgICogYSBjb21wb3NpdGlvbiBpcyBhY3RpdmUgKHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xNDQ5KVxuICAgICAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlICYmIChlbXB0eSB8fCBlZGl0b3Iudmlldy5jb21wb3NpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGFjdGl2ZSBzdGF0ZSBpZiB3ZSBqdXN0IGxlZnQgdGhlIHByZXZpb3VzIHN1Z2dlc3Rpb24gcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKChmcm9tIDwgcHJldi5yYW5nZS5mcm9tIHx8IGZyb20gPiBwcmV2LnJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgIWNvbXBvc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXByZXYuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCBhZ2FpbnN0IHdoZXJlIG91ciBjdXJzb3IgY3VycmVudGx5IGlzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gZmluZFN1Z2dlc3Rpb25NYXRjaCQxKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1NwYWNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93VG9JbmNsdWRlQ2hhcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRQcmVmaXhlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJHBvc2l0aW9uOiBzZWxlY3Rpb24uJGZyb20sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uSWQgPSBgaWRfJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKX1gO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIG1hdGNoLCB1cGRhdGUgdGhlIGN1cnJlbnQgc3RhdGUgdG8gc2hvdyBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGFsbG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IG1hdGNoLnJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBwcmV2LmFjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmRlY29yYXRpb25JZCA9IHByZXYuZGVjb3JhdGlvbklkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwcmV2LmRlY29yYXRpb25JZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGVjb3JhdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5yYW5nZSA9IG1hdGNoLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5xdWVyeSA9IG1hdGNoLnF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50ZXh0ID0gbWF0Y2gudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBlbXB0eSB0aGUgcmFuZ2UgaWYgc3VnZ2VzdGlvbiBpcyBpbmFjdGl2ZVxuICAgICAgICAgICAgICAgIGlmICghbmV4dC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kZWNvcmF0aW9uSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJhbmdlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC50ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgLy8gQ2FsbCB0aGUga2V5ZG93biBob29rIGlmIHN1Z2dlc3Rpb24gaXMgYWN0aXZlLlxuICAgICAgICAgICAgaGFuZGxlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFjdGl2ZSwgcmFuZ2UgfSA9IHBsdWdpbi5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoKF9hID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uS2V5RG93bikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocmVuZGVyZXIsIHsgdmlldywgZXZlbnQsIHJhbmdlIH0pKSB8fCBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBTZXR1cCBkZWNvcmF0b3Igb24gdGhlIGN1cnJlbnRseSBhY3RpdmUgc3VnZ2VzdGlvbi5cbiAgICAgICAgICAgIGRlY29yYXRpb25zKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhY3RpdmUsIHJhbmdlLCBkZWNvcmF0aW9uSWQsIHF1ZXJ5LCB9ID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9ICEocXVlcnkgPT09IG51bGwgfHwgcXVlcnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHF1ZXJ5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFtkZWNvcmF0aW9uQ2xhc3NdO1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaChkZWNvcmF0aW9uRW1wdHlDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtcbiAgICAgICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5pbmxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiBkZWNvcmF0aW9uVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGNsYXNzTmFtZXMuam9pbignICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtZGVjb3JhdGlvbi1pZCc6IGRlY29yYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWRlY29yYXRpb24tY29udGVudCc6IGRlY29yYXRpb25Db250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHBsdWdpbjtcbn1cblxuZXhwb3J0IHsgU3VnZ2VzdGlvbiwgU3VnZ2VzdGlvblBsdWdpbktleSwgU3VnZ2VzdGlvbiBhcyBkZWZhdWx0LCBmaW5kU3VnZ2VzdGlvbk1hdGNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@tiptap+suggestion@2.26.3_@tiptap+core@2.26.3_@tiptap+pm@2.26.3__@tiptap+pm@2.26.3/node_modules/@tiptap/suggestion/dist/index.js\n");

/***/ })

};
;