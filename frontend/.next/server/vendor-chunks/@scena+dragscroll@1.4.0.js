"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scena+dragscroll@1.4.0";
exports.ids = ["vendor-chunks/@scena+dragscroll@1.4.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@scena+dragscroll@1.4.0/node_modules/@scena/dragscroll/dist/dragscroll.esm.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@scena+dragscroll@1.4.0/node_modules/@scena/dragscroll/dist/dragscroll.esm.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scena/event-emitter */ \"(ssr)/./node_modules/.pnpm/@scena+event-emitter@1.0.5/node_modules/@scena/event-emitter/dist/event-emitter.esm.js\");\n/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @daybrush/utils */ \"(ssr)/./node_modules/.pnpm/@daybrush+utils@1.13.0/node_modules/@daybrush/utils/dist/utils.esm.js\");\n/*\nCopyright (c) 2019 Daybrush\nname: @scena/dragscroll\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/dragscroll.git\nversion: 1.4.0\n*/\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\n\nfunction getDefaultScrollPosition(e) {\n  var container = e.container;\n  if (container === document.body) {\n    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];\n  }\n  return [container.scrollLeft, container.scrollTop];\n}\nfunction checkDefaultScrollEvent(container, callback) {\n  container.addEventListener(\"scroll\", callback);\n  return function () {\n    container.removeEventListener(\"scroll\", callback);\n  };\n}\nfunction getContainerElement(container) {\n  if (!container) {\n    return null;\n  } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(container)) {\n    return document.querySelector(container);\n  }\n  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(container)) {\n    return container();\n  } else if (container instanceof Element) {\n    return container;\n  } else if (\"current\" in container) {\n    return container.current;\n  } else if (\"value\" in container) {\n    return container.value;\n  }\n}\n/**\n * @sort 1\n */\nvar DragScroll = /*#__PURE__*/function (_super) {\n  __extends(DragScroll, _super);\n  function DragScroll() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._startRect = null;\n    _this._startPos = [];\n    _this._prevTime = 0;\n    _this._timer = 0;\n    _this._prevScrollPos = [0, 0];\n    _this._isWait = false;\n    _this._flag = false;\n    _this._currentOptions = null;\n    _this._lock = false;\n    _this._unregister = null;\n    _this._onScroll = function () {\n      var options = _this._currentOptions;\n      if (_this._lock || !options) {\n        return;\n      }\n      _this.emit(\"scrollDrag\", {\n        next: function (inputEvent) {\n          _this.checkScroll({\n            container: options.container,\n            inputEvent: inputEvent\n          });\n        }\n      });\n    };\n    return _this;\n  }\n  /**\n   */\n  var __proto = DragScroll.prototype;\n  __proto.dragStart = function (e, options) {\n    var container = getContainerElement(options.container);\n    if (!container) {\n      this._flag = false;\n      return;\n    }\n    var top = 0;\n    var left = 0;\n    var width = 0;\n    var height = 0;\n    if (container === document.body) {\n      width = window.innerWidth;\n      height = window.innerHeight;\n    } else {\n      var rect = container.getBoundingClientRect();\n      top = rect.top;\n      left = rect.left;\n      width = rect.width;\n      height = rect.height;\n    }\n    this._flag = true;\n    this._startPos = [e.clientX, e.clientY];\n    this._startRect = {\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n    this._prevScrollPos = this._getScrollPosition([0, 0], options);\n    this._currentOptions = options;\n    this._registerScrollEvent(options);\n  };\n  __proto.drag = function (e, options) {\n    clearTimeout(this._timer);\n    if (!this._flag) {\n      return;\n    }\n    var clientX = e.clientX,\n      clientY = e.clientY;\n    var _a = options.threshold,\n      threshold = _a === void 0 ? 0 : _a;\n    var _b = this,\n      _startRect = _b._startRect,\n      _startPos = _b._startPos;\n    this._currentOptions = options;\n    var direction = [0, 0];\n    if (_startRect.top > clientY - threshold) {\n      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {\n        direction[1] = -1;\n      }\n    } else if (_startRect.top + _startRect.height < clientY + threshold) {\n      if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {\n        direction[1] = 1;\n      }\n    }\n    if (_startRect.left > clientX - threshold) {\n      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {\n        direction[0] = -1;\n      }\n    } else if (_startRect.left + _startRect.width < clientX + threshold) {\n      if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {\n        direction[0] = 1;\n      }\n    }\n    if (!direction[0] && !direction[1]) {\n      return false;\n    }\n    return this._continueDrag(__assign(__assign({}, options), {\n      direction: direction,\n      inputEvent: e,\n      isDrag: true\n    }));\n  };\n  /**\n   */\n  __proto.checkScroll = function (options) {\n    var _this = this;\n    if (this._isWait) {\n      return false;\n    }\n    var _a = options.prevScrollPos,\n      prevScrollPos = _a === void 0 ? this._prevScrollPos : _a,\n      direction = options.direction,\n      _b = options.throttleTime,\n      throttleTime = _b === void 0 ? 0 : _b,\n      inputEvent = options.inputEvent,\n      isDrag = options.isDrag;\n    var nextScrollPos = this._getScrollPosition(direction || [0, 0], options);\n    var offsetX = nextScrollPos[0] - prevScrollPos[0];\n    var offsetY = nextScrollPos[1] - prevScrollPos[1];\n    var nextDirection = direction || [offsetX ? Math.abs(offsetX) / offsetX : 0, offsetY ? Math.abs(offsetY) / offsetY : 0];\n    this._prevScrollPos = nextScrollPos;\n    this._lock = false;\n    if (!offsetX && !offsetY) {\n      return false;\n    }\n    /**\n     * @event DragScroll#move\n     */\n    this.emit(\"move\", {\n      offsetX: nextDirection[0] ? offsetX : 0,\n      offsetY: nextDirection[1] ? offsetY : 0,\n      inputEvent: inputEvent\n    });\n    if (throttleTime && isDrag) {\n      clearTimeout(this._timer);\n      this._timer = window.setTimeout(function () {\n        _this._continueDrag(options);\n      }, throttleTime);\n    }\n    return true;\n  };\n  /**\n   *\n   */\n  __proto.dragEnd = function () {\n    this._flag = false;\n    this._lock = false;\n    clearTimeout(this._timer);\n    this._unregisterScrollEvent();\n  };\n  __proto._getScrollPosition = function (direction, options) {\n    var container = options.container,\n      _a = options.getScrollPosition,\n      getScrollPosition = _a === void 0 ? getDefaultScrollPosition : _a;\n    return getScrollPosition({\n      container: getContainerElement(container),\n      direction: direction\n    });\n  };\n  __proto._continueDrag = function (options) {\n    var _this = this;\n    var _a;\n    var container = options.container,\n      direction = options.direction,\n      throttleTime = options.throttleTime,\n      useScroll = options.useScroll,\n      isDrag = options.isDrag,\n      inputEvent = options.inputEvent;\n    if (!this._flag || isDrag && this._isWait) {\n      return;\n    }\n    var nowTime = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)();\n    var distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);\n    if (distTime > 0) {\n      clearTimeout(this._timer);\n      this._timer = window.setTimeout(function () {\n        _this._continueDrag(options);\n      }, distTime);\n      return false;\n    }\n    this._prevTime = nowTime;\n    var prevScrollPos = this._getScrollPosition(direction, options);\n    this._prevScrollPos = prevScrollPos;\n    if (isDrag) {\n      this._isWait = true;\n    }\n    // unregister native scroll event\n    if (!useScroll) {\n      this._lock = true;\n    }\n    var param = {\n      container: getContainerElement(container),\n      direction: direction,\n      inputEvent: inputEvent\n    };\n    (_a = options.requestScroll) === null || _a === void 0 ? void 0 : _a.call(options, param);\n    /**\n     * @event DragScroll#scroll\n     */\n    this.emit(\"scroll\", param);\n    this._isWait = false;\n    return useScroll || this.checkScroll(__assign(__assign({}, options), {\n      prevScrollPos: prevScrollPos,\n      direction: direction,\n      inputEvent: inputEvent\n    }));\n  };\n  __proto._registerScrollEvent = function (options) {\n    this._unregisterScrollEvent();\n    var checkScrollEvent = options.checkScrollEvent;\n    if (!checkScrollEvent) {\n      return;\n    }\n    var callback = checkScrollEvent === true ? checkDefaultScrollEvent : checkScrollEvent;\n    var container = getContainerElement(options.container);\n    if (checkScrollEvent === true && (container === document.body || container === document.documentElement)) {\n      this._unregister = checkDefaultScrollEvent(window, this._onScroll);\n    } else {\n      this._unregister = callback(container, this._onScroll);\n    }\n  };\n  __proto._unregisterScrollEvent = function () {\n    var _a;\n    (_a = this._unregister) === null || _a === void 0 ? void 0 : _a.call(this);\n    this._unregister = null;\n  };\n  return DragScroll;\n}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragScroll);\n//# sourceMappingURL=dragscroll.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNjZW5hK2RyYWdzY3JvbGxAMS40LjAvbm9kZV9tb2R1bGVzL0BzY2VuYS9kcmFnc2Nyb2xsL2Rpc3QvZHJhZ3Njcm9sbC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUNZOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMseURBQVE7QUFDckI7QUFDQTtBQUNBLE1BQU0sMkRBQVU7QUFDaEI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDREQUFZOztBQUVkLGlFQUFlLFVBQVUsRUFBQztBQUMxQiIsInNvdXJjZXMiOlsiL3Jvb3QvdGhlMTEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BzY2VuYStkcmFnc2Nyb2xsQDEuNC4wL25vZGVfbW9kdWxlcy9Ac2NlbmEvZHJhZ3Njcm9sbC9kaXN0L2RyYWdzY3JvbGwuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IEBzY2VuYS9kcmFnc2Nyb2xsXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvZHJhZ3Njcm9sbC5naXRcbnZlcnNpb246IDEuNC4wXG4qL1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdAc2NlbmEvZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgeyBub3csIGlzU3RyaW5nLCBpc0Z1bmN0aW9uIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9O1xuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRTY3JvbGxQb3NpdGlvbihlKSB7XG4gIHZhciBjb250YWluZXIgPSBlLmNvbnRhaW5lcjtcbiAgaWYgKGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBbY29udGFpbmVyLnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsIGNvbnRhaW5lci5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcF07XG4gIH1cbiAgcmV0dXJuIFtjb250YWluZXIuc2Nyb2xsTGVmdCwgY29udGFpbmVyLnNjcm9sbFRvcF07XG59XG5mdW5jdGlvbiBjaGVja0RlZmF1bHRTY3JvbGxFdmVudChjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBjYWxsYmFjayk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJFbGVtZW50KGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKGNvbnRhaW5lcikpIHtcbiAgICByZXR1cm4gY29udGFpbmVyKCk7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH0gZWxzZSBpZiAoXCJjdXJyZW50XCIgaW4gY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5jdXJyZW50O1xuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBjb250YWluZXIpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLnZhbHVlO1xuICB9XG59XG4vKipcbiAqIEBzb3J0IDFcbiAqL1xudmFyIERyYWdTY3JvbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRHJhZ1Njcm9sbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRHJhZ1Njcm9sbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5fc3RhcnRSZWN0ID0gbnVsbDtcbiAgICBfdGhpcy5fc3RhcnRQb3MgPSBbXTtcbiAgICBfdGhpcy5fcHJldlRpbWUgPSAwO1xuICAgIF90aGlzLl90aW1lciA9IDA7XG4gICAgX3RoaXMuX3ByZXZTY3JvbGxQb3MgPSBbMCwgMF07XG4gICAgX3RoaXMuX2lzV2FpdCA9IGZhbHNlO1xuICAgIF90aGlzLl9mbGFnID0gZmFsc2U7XG4gICAgX3RoaXMuX2N1cnJlbnRPcHRpb25zID0gbnVsbDtcbiAgICBfdGhpcy5fbG9jayA9IGZhbHNlO1xuICAgIF90aGlzLl91bnJlZ2lzdGVyID0gbnVsbDtcbiAgICBfdGhpcy5fb25TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLl9jdXJyZW50T3B0aW9ucztcbiAgICAgIGlmIChfdGhpcy5fbG9jayB8fCAhb3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfdGhpcy5lbWl0KFwic2Nyb2xsRHJhZ1wiLCB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIChpbnB1dEV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMuY2hlY2tTY3JvbGwoe1xuICAgICAgICAgICAgY29udGFpbmVyOiBvcHRpb25zLmNvbnRhaW5lcixcbiAgICAgICAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqL1xuICB2YXIgX19wcm90byA9IERyYWdTY3JvbGwucHJvdG90eXBlO1xuICBfX3Byb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGdldENvbnRhaW5lckVsZW1lbnQob3B0aW9ucy5jb250YWluZXIpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB0aGlzLl9mbGFnID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0b3AgPSAwO1xuICAgIHZhciBsZWZ0ID0gMDtcbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIHZhciBoZWlnaHQgPSAwO1xuICAgIGlmIChjb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdG9wID0gcmVjdC50b3A7XG4gICAgICBsZWZ0ID0gcmVjdC5sZWZ0O1xuICAgICAgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuX2ZsYWcgPSB0cnVlO1xuICAgIHRoaXMuX3N0YXJ0UG9zID0gW2UuY2xpZW50WCwgZS5jbGllbnRZXTtcbiAgICB0aGlzLl9zdGFydFJlY3QgPSB7XG4gICAgICB0b3A6IHRvcCxcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gICAgdGhpcy5fcHJldlNjcm9sbFBvcyA9IHRoaXMuX2dldFNjcm9sbFBvc2l0aW9uKFswLCAwXSwgb3B0aW9ucyk7XG4gICAgdGhpcy5fY3VycmVudE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3JlZ2lzdGVyU2Nyb2xsRXZlbnQob3B0aW9ucyk7XG4gIH07XG4gIF9fcHJvdG8uZHJhZyA9IGZ1bmN0aW9uIChlLCBvcHRpb25zKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICBpZiAoIXRoaXMuX2ZsYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFgsXG4gICAgICBjbGllbnRZID0gZS5jbGllbnRZO1xuICAgIHZhciBfYSA9IG9wdGlvbnMudGhyZXNob2xkLFxuICAgICAgdGhyZXNob2xkID0gX2EgPT09IHZvaWQgMCA/IDAgOiBfYTtcbiAgICB2YXIgX2IgPSB0aGlzLFxuICAgICAgX3N0YXJ0UmVjdCA9IF9iLl9zdGFydFJlY3QsXG4gICAgICBfc3RhcnRQb3MgPSBfYi5fc3RhcnRQb3M7XG4gICAgdGhpcy5fY3VycmVudE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBkaXJlY3Rpb24gPSBbMCwgMF07XG4gICAgaWYgKF9zdGFydFJlY3QudG9wID4gY2xpZW50WSAtIHRocmVzaG9sZCkge1xuICAgICAgaWYgKF9zdGFydFBvc1sxXSA+IF9zdGFydFJlY3QudG9wIHx8IGNsaWVudFkgPCBfc3RhcnRQb3NbMV0pIHtcbiAgICAgICAgZGlyZWN0aW9uWzFdID0gLTE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfc3RhcnRSZWN0LnRvcCArIF9zdGFydFJlY3QuaGVpZ2h0IDwgY2xpZW50WSArIHRocmVzaG9sZCkge1xuICAgICAgaWYgKF9zdGFydFBvc1sxXSA8IF9zdGFydFJlY3QudG9wICsgX3N0YXJ0UmVjdC5oZWlnaHQgfHwgY2xpZW50WSA+IF9zdGFydFBvc1sxXSkge1xuICAgICAgICBkaXJlY3Rpb25bMV0gPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX3N0YXJ0UmVjdC5sZWZ0ID4gY2xpZW50WCAtIHRocmVzaG9sZCkge1xuICAgICAgaWYgKF9zdGFydFBvc1swXSA+IF9zdGFydFJlY3QubGVmdCB8fCBjbGllbnRYIDwgX3N0YXJ0UG9zWzBdKSB7XG4gICAgICAgIGRpcmVjdGlvblswXSA9IC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3N0YXJ0UmVjdC5sZWZ0ICsgX3N0YXJ0UmVjdC53aWR0aCA8IGNsaWVudFggKyB0aHJlc2hvbGQpIHtcbiAgICAgIGlmIChfc3RhcnRQb3NbMF0gPCBfc3RhcnRSZWN0LmxlZnQgKyBfc3RhcnRSZWN0LndpZHRoIHx8IGNsaWVudFggPiBfc3RhcnRQb3NbMF0pIHtcbiAgICAgICAgZGlyZWN0aW9uWzBdID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY29udGludWVEcmFnKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICBpbnB1dEV2ZW50OiBlLFxuICAgICAgaXNEcmFnOiB0cnVlXG4gICAgfSkpO1xuICB9O1xuICAvKipcbiAgICovXG4gIF9fcHJvdG8uY2hlY2tTY3JvbGwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2lzV2FpdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZXZTY3JvbGxQb3MsXG4gICAgICBwcmV2U2Nyb2xsUG9zID0gX2EgPT09IHZvaWQgMCA/IHRoaXMuX3ByZXZTY3JvbGxQb3MgOiBfYSxcbiAgICAgIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uLFxuICAgICAgX2IgPSBvcHRpb25zLnRocm90dGxlVGltZSxcbiAgICAgIHRocm90dGxlVGltZSA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsXG4gICAgICBpbnB1dEV2ZW50ID0gb3B0aW9ucy5pbnB1dEV2ZW50LFxuICAgICAgaXNEcmFnID0gb3B0aW9ucy5pc0RyYWc7XG4gICAgdmFyIG5leHRTY3JvbGxQb3MgPSB0aGlzLl9nZXRTY3JvbGxQb3NpdGlvbihkaXJlY3Rpb24gfHwgWzAsIDBdLCBvcHRpb25zKTtcbiAgICB2YXIgb2Zmc2V0WCA9IG5leHRTY3JvbGxQb3NbMF0gLSBwcmV2U2Nyb2xsUG9zWzBdO1xuICAgIHZhciBvZmZzZXRZID0gbmV4dFNjcm9sbFBvc1sxXSAtIHByZXZTY3JvbGxQb3NbMV07XG4gICAgdmFyIG5leHREaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgW29mZnNldFggPyBNYXRoLmFicyhvZmZzZXRYKSAvIG9mZnNldFggOiAwLCBvZmZzZXRZID8gTWF0aC5hYnMob2Zmc2V0WSkgLyBvZmZzZXRZIDogMF07XG4gICAgdGhpcy5fcHJldlNjcm9sbFBvcyA9IG5leHRTY3JvbGxQb3M7XG4gICAgdGhpcy5fbG9jayA9IGZhbHNlO1xuICAgIGlmICghb2Zmc2V0WCAmJiAhb2Zmc2V0WSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgRHJhZ1Njcm9sbCNtb3ZlXG4gICAgICovXG4gICAgdGhpcy5lbWl0KFwibW92ZVwiLCB7XG4gICAgICBvZmZzZXRYOiBuZXh0RGlyZWN0aW9uWzBdID8gb2Zmc2V0WCA6IDAsXG4gICAgICBvZmZzZXRZOiBuZXh0RGlyZWN0aW9uWzFdID8gb2Zmc2V0WSA6IDAsXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgfSk7XG4gICAgaWYgKHRocm90dGxlVGltZSAmJiBpc0RyYWcpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICB0aGlzLl90aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX2NvbnRpbnVlRHJhZyhvcHRpb25zKTtcbiAgICAgIH0sIHRocm90dGxlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICpcbiAgICovXG4gIF9fcHJvdG8uZHJhZ0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mbGFnID0gZmFsc2U7XG4gICAgdGhpcy5fbG9jayA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgdGhpcy5fdW5yZWdpc3RlclNjcm9sbEV2ZW50KCk7XG4gIH07XG4gIF9fcHJvdG8uX2dldFNjcm9sbFBvc2l0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcixcbiAgICAgIF9hID0gb3B0aW9ucy5nZXRTY3JvbGxQb3NpdGlvbixcbiAgICAgIGdldFNjcm9sbFBvc2l0aW9uID0gX2EgPT09IHZvaWQgMCA/IGdldERlZmF1bHRTY3JvbGxQb3NpdGlvbiA6IF9hO1xuICAgIHJldHVybiBnZXRTY3JvbGxQb3NpdGlvbih7XG4gICAgICBjb250YWluZXI6IGdldENvbnRhaW5lckVsZW1lbnQoY29udGFpbmVyKSxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2NvbnRpbnVlRHJhZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2E7XG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyLFxuICAgICAgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24sXG4gICAgICB0aHJvdHRsZVRpbWUgPSBvcHRpb25zLnRocm90dGxlVGltZSxcbiAgICAgIHVzZVNjcm9sbCA9IG9wdGlvbnMudXNlU2Nyb2xsLFxuICAgICAgaXNEcmFnID0gb3B0aW9ucy5pc0RyYWcsXG4gICAgICBpbnB1dEV2ZW50ID0gb3B0aW9ucy5pbnB1dEV2ZW50O1xuICAgIGlmICghdGhpcy5fZmxhZyB8fCBpc0RyYWcgJiYgdGhpcy5faXNXYWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3dUaW1lID0gbm93KCk7XG4gICAgdmFyIGRpc3RUaW1lID0gTWF0aC5tYXgodGhyb3R0bGVUaW1lICsgdGhpcy5fcHJldlRpbWUgLSBub3dUaW1lLCAwKTtcbiAgICBpZiAoZGlzdFRpbWUgPiAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgICAgdGhpcy5fdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9jb250aW51ZURyYWcob3B0aW9ucyk7XG4gICAgICB9LCBkaXN0VGltZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3ByZXZUaW1lID0gbm93VGltZTtcbiAgICB2YXIgcHJldlNjcm9sbFBvcyA9IHRoaXMuX2dldFNjcm9sbFBvc2l0aW9uKGRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgdGhpcy5fcHJldlNjcm9sbFBvcyA9IHByZXZTY3JvbGxQb3M7XG4gICAgaWYgKGlzRHJhZykge1xuICAgICAgdGhpcy5faXNXYWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gdW5yZWdpc3RlciBuYXRpdmUgc2Nyb2xsIGV2ZW50XG4gICAgaWYgKCF1c2VTY3JvbGwpIHtcbiAgICAgIHRoaXMuX2xvY2sgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgcGFyYW0gPSB7XG4gICAgICBjb250YWluZXI6IGdldENvbnRhaW5lckVsZW1lbnQoY29udGFpbmVyKSxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudFxuICAgIH07XG4gICAgKF9hID0gb3B0aW9ucy5yZXF1ZXN0U2Nyb2xsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBwYXJhbSk7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IERyYWdTY3JvbGwjc2Nyb2xsXG4gICAgICovXG4gICAgdGhpcy5lbWl0KFwic2Nyb2xsXCIsIHBhcmFtKTtcbiAgICB0aGlzLl9pc1dhaXQgPSBmYWxzZTtcbiAgICByZXR1cm4gdXNlU2Nyb2xsIHx8IHRoaXMuY2hlY2tTY3JvbGwoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICBwcmV2U2Nyb2xsUG9zOiBwcmV2U2Nyb2xsUG9zLFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgfSkpO1xuICB9O1xuICBfX3Byb3RvLl9yZWdpc3RlclNjcm9sbEV2ZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyU2Nyb2xsRXZlbnQoKTtcbiAgICB2YXIgY2hlY2tTY3JvbGxFdmVudCA9IG9wdGlvbnMuY2hlY2tTY3JvbGxFdmVudDtcbiAgICBpZiAoIWNoZWNrU2Nyb2xsRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNhbGxiYWNrID0gY2hlY2tTY3JvbGxFdmVudCA9PT0gdHJ1ZSA/IGNoZWNrRGVmYXVsdFNjcm9sbEV2ZW50IDogY2hlY2tTY3JvbGxFdmVudDtcbiAgICB2YXIgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyRWxlbWVudChvcHRpb25zLmNvbnRhaW5lcik7XG4gICAgaWYgKGNoZWNrU2Nyb2xsRXZlbnQgPT09IHRydWUgJiYgKGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSB8fCBjb250YWluZXIgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHRoaXMuX3VucmVnaXN0ZXIgPSBjaGVja0RlZmF1bHRTY3JvbGxFdmVudCh3aW5kb3csIHRoaXMuX29uU2Nyb2xsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdW5yZWdpc3RlciA9IGNhbGxiYWNrKGNvbnRhaW5lciwgdGhpcy5fb25TY3JvbGwpO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5fdW5yZWdpc3RlclNjcm9sbEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLl91bnJlZ2lzdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl91bnJlZ2lzdGVyID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIERyYWdTY3JvbGw7XG59KEV2ZW50RW1pdHRlcik7XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdTY3JvbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmFnc2Nyb2xsLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@scena+dragscroll@1.4.0/node_modules/@scena/dragscroll/dist/dragscroll.esm.js\n");

/***/ })

};
;