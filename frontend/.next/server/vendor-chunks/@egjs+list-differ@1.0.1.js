"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@egjs+list-differ@1.0.1";
exports.ids = ["vendor-chunks/@egjs+list-differ@1.0.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@egjs+list-differ@1.0.1/node_modules/@egjs/list-differ/dist/list-differ.esm.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@egjs+list-differ@1.0.1/node_modules/@egjs/list-differ/dist/list-differ.esm.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   diff: () => (/* binding */ diff)\n/* harmony export */ });\n/*\nCopyright (c) 2019-present NAVER Corp.\nname: @egjs/list-differ\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-list-differ\nversion: 1.0.1\n*/\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar PolyMap =\n/*#__PURE__*/\nfunction () {\n  function PolyMap() {\n    this.keys = [];\n    this.values = [];\n  }\n\n  var __proto = PolyMap.prototype;\n\n  __proto.get = function (key) {\n    return this.values[this.keys.indexOf(key)];\n  };\n\n  __proto.set = function (key, value) {\n    var keys = this.keys;\n    var values = this.values;\n    var prevIndex = keys.indexOf(key);\n    var index = prevIndex === -1 ? keys.length : prevIndex;\n    keys[index] = key;\n    values[index] = value;\n  };\n\n  return PolyMap;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar HashMap =\n/*#__PURE__*/\nfunction () {\n  function HashMap() {\n    this.object = {};\n  }\n\n  var __proto = HashMap.prototype;\n\n  __proto.get = function (key) {\n    return this.object[key];\n  };\n\n  __proto.set = function (key, value) {\n    this.object[key] = value;\n  };\n\n  return HashMap;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar SUPPORT_MAP = typeof Map === \"function\";\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar Link =\n/*#__PURE__*/\nfunction () {\n  function Link() {}\n\n  var __proto = Link.prototype;\n\n  __proto.connect = function (prevLink, nextLink) {\n    this.prev = prevLink;\n    this.next = nextLink;\n    prevLink && (prevLink.next = this);\n    nextLink && (nextLink.prev = this);\n  };\n\n  __proto.disconnect = function () {\n    // In double linked list, diconnect the interconnected relationship.\n    var prevLink = this.prev;\n    var nextLink = this.next;\n    prevLink && (prevLink.next = nextLink);\n    nextLink && (nextLink.prev = prevLink);\n  };\n\n  __proto.getIndex = function () {\n    var link = this;\n    var index = -1;\n\n    while (link) {\n      link = link.prev;\n      ++index;\n    }\n\n    return index;\n  };\n\n  return Link;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\nfunction orderChanged(changed, fixed) {\n  // It is roughly in the order of these examples.\n  // 4, 6, 0, 2, 1, 3, 5, 7\n  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7\n\n  var toLinks = [];\n  changed.forEach(function (_a) {\n    var from = _a[0],\n        to = _a[1];\n    var link = new Link();\n    fromLinks[from] = link;\n    toLinks[to] = link;\n  }); // `fromLinks` are connected to each other by double linked list.\n\n  fromLinks.forEach(function (link, i) {\n    link.connect(fromLinks[i - 1]);\n  });\n  return changed.filter(function (_, i) {\n    return !fixed[i];\n  }).map(function (_a, i) {\n    var from = _a[0],\n        to = _a[1];\n\n    if (from === to) {\n      return [0, 0];\n    }\n\n    var fromLink = fromLinks[from];\n    var toLink = toLinks[to - 1];\n    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.\n\n    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.\n\n    if (!toLink) {\n      fromLink.connect(undefined, fromLinks[0]);\n    } else {\n      fromLink.connect(toLink, toLink.next);\n    }\n\n    var toIndex = fromLink.getIndex();\n    return [fromIndex, toIndex];\n  });\n}\n\nvar Result =\n/*#__PURE__*/\nfunction () {\n  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {\n    this.prevList = prevList;\n    this.list = list;\n    this.added = added;\n    this.removed = removed;\n    this.changed = changed;\n    this.maintained = maintained;\n    this.changedBeforeAdded = changedBeforeAdded;\n    this.fixed = fixed;\n  }\n\n  var __proto = Result.prototype;\n  Object.defineProperty(__proto, \"ordered\", {\n    get: function () {\n      if (!this.cacheOrdered) {\n        this.caculateOrdered();\n      }\n\n      return this.cacheOrdered;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"pureChanged\", {\n    get: function () {\n      if (!this.cachePureChanged) {\n        this.caculateOrdered();\n      }\n\n      return this.cachePureChanged;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __proto.caculateOrdered = function () {\n    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);\n    var changed = this.changed;\n    var pureChanged = [];\n    this.cacheOrdered = ordered.filter(function (_a, i) {\n      var from = _a[0],\n          to = _a[1];\n      var _b = changed[i],\n          fromBefore = _b[0],\n          toBefore = _b[1];\n\n      if (from !== to) {\n        pureChanged.push([fromBefore, toBefore]);\n        return true;\n      }\n    });\n    this.cachePureChanged = pureChanged;\n  };\n\n  return Result;\n}();\n\n/**\n *\n * @memberof eg.ListDiffer\n * @static\n * @function\n * @param - Previous List <ko> 이전 목록 </ko>\n * @param - List to Update <ko> 업데이트 할 목록 </ko>\n * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>\n * @example\n * import { diff } from \"@egjs/list-differ\";\n * // script => eg.ListDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\n\nfunction diff(prevList, list, findKeyCallback) {\n  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;\n\n  var callback = findKeyCallback || function (e) {\n    return e;\n  };\n\n  var added = [];\n  var removed = [];\n  var maintained = [];\n  var prevKeys = prevList.map(callback);\n  var keys = list.map(callback);\n  var prevKeyMap = new mapClass();\n  var keyMap = new mapClass();\n  var changedBeforeAdded = [];\n  var fixed = [];\n  var removedMap = {};\n  var changed = [];\n  var addedCount = 0;\n  var removedCount = 0; // Add prevKeys and keys to the hashmap.\n\n  prevKeys.forEach(function (key, prevListIndex) {\n    prevKeyMap.set(key, prevListIndex);\n  });\n  keys.forEach(function (key, listIndex) {\n    keyMap.set(key, listIndex);\n  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.\n\n  prevKeys.forEach(function (key, prevListIndex) {\n    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.\n\n    if (typeof listIndex === \"undefined\") {\n      ++removedCount;\n      removed.push(prevListIndex);\n    } else {\n      removedMap[listIndex] = removedCount;\n    }\n  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.\n\n  keys.forEach(function (key, listIndex) {\n    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.\n\n    if (typeof prevListIndex === \"undefined\") {\n      added.push(listIndex);\n      ++addedCount;\n    } else {\n      maintained.push([prevListIndex, listIndex]);\n      removedCount = removedMap[listIndex] || 0;\n      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);\n      fixed.push(listIndex === prevListIndex);\n\n      if (prevListIndex !== listIndex) {\n        changed.push([prevListIndex, listIndex]);\n      }\n    }\n  }); // Sort by ascending order of 'to(list's index).\n\n  removed.reverse();\n  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);\n}\n\n/**\n * A module that checks diff when values are added, removed, or changed in an array.\n * @ko 배열 또는 오브젝트에서 값이 추가되거나 삭제되거나 순서가 변경사항을 체크하는 모듈입니다.\n * @memberof eg\n */\n\nvar ListDiffer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param - Initializing Data Array. <ko> 초기 설정할 데이터 배열.</ko>\n   * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>\n   * @example\n   * import ListDiffer from \"@egjs/list-differ\";\n   * // script => eg.ListDiffer\n   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);\n   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);\n   * // List before update\n   * // [1, 2, 3, 4, 5]\n   * console.log(result.prevList);\n   * // Updated list\n   * // [4, 3, 6, 2, 1]\n   * console.log(result.list);\n   * // Index array of values added to `list`.\n   * // [0, 1, 5]\n   * console.log(result.added);\n   * // Index array of values removed in `prevList`.\n   * // [5]\n   * console.log(result.removed);\n   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.changed);\n   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n   * // [[4, 3], [3, 4], [2, 6]]\n   * console.log(result.pureChanged);\n   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n   * // [[4, 1], [4, 2], [4, 3]]\n   * console.log(result.ordered);\n   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.maintained);\n   */\n  function ListDiffer(list, findKeyCallback) {\n    if (list === void 0) {\n      list = [];\n    }\n\n    this.findKeyCallback = findKeyCallback;\n    this.list = [].slice.call(list);\n  }\n  /**\n   * Update list.\n   * @ko 리스트를 업데이트를 합니다.\n   * @param - List to update <ko> 업데이트할 리스트 </ko>\n   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList`에서 `list`로 업데이트한 결과를 반환한다. </ko>\n   */\n\n\n  var __proto = ListDiffer.prototype;\n\n  __proto.update = function (list) {\n    var newData = [].slice.call(list);\n    var result = diff(this.list, newData, this.findKeyCallback);\n    this.list = newData;\n    return result;\n  };\n\n  return ListDiffer;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListDiffer);\n\n//# sourceMappingURL=list-differ.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGVnanMrbGlzdC1kaWZmZXJAMS4wLjEvbm9kZV9tb2R1bGVzL0BlZ2pzL2xpc3QtZGlmZmVyL2Rpc3QvbGlzdC1kaWZmZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QywyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFVBQVUsRUFBQztBQUNWO0FBQ2hCIiwic291cmNlcyI6WyIvcm9vdC90aGUxMS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQGVnanMrbGlzdC1kaWZmZXJAMS4wLjEvbm9kZV9tb2R1bGVzL0BlZ2pzL2xpc3QtZGlmZmVyL2Rpc3QvbGlzdC1kaWZmZXIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvbGlzdC1kaWZmZXJcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtbGlzdC1kaWZmZXJcbnZlcnNpb246IDEuMC4xXG4qL1xuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBQb2x5TWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9seU1hcCgpIHtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBQb2x5TWFwLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5rZXlzLmluZGV4T2Yoa2V5KV07XG4gIH07XG5cbiAgX19wcm90by5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICB2YXIgcHJldkluZGV4ID0ga2V5cy5pbmRleE9mKGtleSk7XG4gICAgdmFyIGluZGV4ID0gcHJldkluZGV4ID09PSAtMSA/IGtleXMubGVuZ3RoIDogcHJldkluZGV4O1xuICAgIGtleXNbaW5kZXhdID0ga2V5O1xuICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gUG9seU1hcDtcbn0oKTtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBIYXNoTWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGFzaE1hcCgpIHtcbiAgICB0aGlzLm9iamVjdCA9IHt9O1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBIYXNoTWFwLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3Rba2V5XTtcbiAgfTtcblxuICBfX3Byb3RvLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5vYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBIYXNoTWFwO1xufSgpO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIFNVUFBPUlRfTUFQID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIExpbmsgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5rKCkge31cblxuICB2YXIgX19wcm90byA9IExpbmsucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uIChwcmV2TGluaywgbmV4dExpbmspIHtcbiAgICB0aGlzLnByZXYgPSBwcmV2TGluaztcbiAgICB0aGlzLm5leHQgPSBuZXh0TGluaztcbiAgICBwcmV2TGluayAmJiAocHJldkxpbmsubmV4dCA9IHRoaXMpO1xuICAgIG5leHRMaW5rICYmIChuZXh0TGluay5wcmV2ID0gdGhpcyk7XG4gIH07XG5cbiAgX19wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEluIGRvdWJsZSBsaW5rZWQgbGlzdCwgZGljb25uZWN0IHRoZSBpbnRlcmNvbm5lY3RlZCByZWxhdGlvbnNoaXAuXG4gICAgdmFyIHByZXZMaW5rID0gdGhpcy5wcmV2O1xuICAgIHZhciBuZXh0TGluayA9IHRoaXMubmV4dDtcbiAgICBwcmV2TGluayAmJiAocHJldkxpbmsubmV4dCA9IG5leHRMaW5rKTtcbiAgICBuZXh0TGluayAmJiAobmV4dExpbmsucHJldiA9IHByZXZMaW5rKTtcbiAgfTtcblxuICBfX3Byb3RvLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaW5rID0gdGhpcztcbiAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgIHdoaWxlIChsaW5rKSB7XG4gICAgICBsaW5rID0gbGluay5wcmV2O1xuICAgICAgKytpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgcmV0dXJuIExpbms7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG5cbmZ1bmN0aW9uIG9yZGVyQ2hhbmdlZChjaGFuZ2VkLCBmaXhlZCkge1xuICAvLyBJdCBpcyByb3VnaGx5IGluIHRoZSBvcmRlciBvZiB0aGVzZSBleGFtcGxlcy5cbiAgLy8gNCwgNiwgMCwgMiwgMSwgMywgNSwgN1xuICB2YXIgZnJvbUxpbmtzID0gW107IC8vIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDdcblxuICB2YXIgdG9MaW5rcyA9IFtdO1xuICBjaGFuZ2VkLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGZyb20gPSBfYVswXSxcbiAgICAgICAgdG8gPSBfYVsxXTtcbiAgICB2YXIgbGluayA9IG5ldyBMaW5rKCk7XG4gICAgZnJvbUxpbmtzW2Zyb21dID0gbGluaztcbiAgICB0b0xpbmtzW3RvXSA9IGxpbms7XG4gIH0pOyAvLyBgZnJvbUxpbmtzYCBhcmUgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIgYnkgZG91YmxlIGxpbmtlZCBsaXN0LlxuXG4gIGZyb21MaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rLCBpKSB7XG4gICAgbGluay5jb25uZWN0KGZyb21MaW5rc1tpIC0gMV0pO1xuICB9KTtcbiAgcmV0dXJuIGNoYW5nZWQuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgcmV0dXJuICFmaXhlZFtpXTtcbiAgfSkubWFwKGZ1bmN0aW9uIChfYSwgaSkge1xuICAgIHZhciBmcm9tID0gX2FbMF0sXG4gICAgICAgIHRvID0gX2FbMV07XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuXG4gICAgdmFyIGZyb21MaW5rID0gZnJvbUxpbmtzW2Zyb21dO1xuICAgIHZhciB0b0xpbmsgPSB0b0xpbmtzW3RvIC0gMV07XG4gICAgdmFyIGZyb21JbmRleCA9IGZyb21MaW5rLmdldEluZGV4KCk7IC8vIERpc2Nvbm5lY3QgdGhlIGxpbmsgY29ubmVjdGVkIHRvIGBmcm9tTGlua2AuXG5cbiAgICBmcm9tTGluay5kaXNjb25uZWN0KCk7IC8vIENvbm5lY3QgYGZyb21MaW5rYCB0byB0aGUgcmlnaHQgb2YgYHRvTGlua2AuXG5cbiAgICBpZiAoIXRvTGluaykge1xuICAgICAgZnJvbUxpbmsuY29ubmVjdCh1bmRlZmluZWQsIGZyb21MaW5rc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21MaW5rLmNvbm5lY3QodG9MaW5rLCB0b0xpbmsubmV4dCk7XG4gICAgfVxuXG4gICAgdmFyIHRvSW5kZXggPSBmcm9tTGluay5nZXRJbmRleCgpO1xuICAgIHJldHVybiBbZnJvbUluZGV4LCB0b0luZGV4XTtcbiAgfSk7XG59XG5cbnZhciBSZXN1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXN1bHQocHJldkxpc3QsIGxpc3QsIGFkZGVkLCByZW1vdmVkLCBjaGFuZ2VkLCBtYWludGFpbmVkLCBjaGFuZ2VkQmVmb3JlQWRkZWQsIGZpeGVkKSB7XG4gICAgdGhpcy5wcmV2TGlzdCA9IHByZXZMaXN0O1xuICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgdGhpcy5hZGRlZCA9IGFkZGVkO1xuICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgdGhpcy5jaGFuZ2VkID0gY2hhbmdlZDtcbiAgICB0aGlzLm1haW50YWluZWQgPSBtYWludGFpbmVkO1xuICAgIHRoaXMuY2hhbmdlZEJlZm9yZUFkZGVkID0gY2hhbmdlZEJlZm9yZUFkZGVkO1xuICAgIHRoaXMuZml4ZWQgPSBmaXhlZDtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gUmVzdWx0LnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwib3JkZXJlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FjaGVPcmRlcmVkKSB7XG4gICAgICAgIHRoaXMuY2FjdWxhdGVPcmRlcmVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlT3JkZXJlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwdXJlQ2hhbmdlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FjaGVQdXJlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLmNhY3VsYXRlT3JkZXJlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVB1cmVDaGFuZ2VkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgX19wcm90by5jYWN1bGF0ZU9yZGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yZGVyZWQgPSBvcmRlckNoYW5nZWQodGhpcy5jaGFuZ2VkQmVmb3JlQWRkZWQsIHRoaXMuZml4ZWQpO1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5jaGFuZ2VkO1xuICAgIHZhciBwdXJlQ2hhbmdlZCA9IFtdO1xuICAgIHRoaXMuY2FjaGVPcmRlcmVkID0gb3JkZXJlZC5maWx0ZXIoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgICB2YXIgZnJvbSA9IF9hWzBdLFxuICAgICAgICAgIHRvID0gX2FbMV07XG4gICAgICB2YXIgX2IgPSBjaGFuZ2VkW2ldLFxuICAgICAgICAgIGZyb21CZWZvcmUgPSBfYlswXSxcbiAgICAgICAgICB0b0JlZm9yZSA9IF9iWzFdO1xuXG4gICAgICBpZiAoZnJvbSAhPT0gdG8pIHtcbiAgICAgICAgcHVyZUNoYW5nZWQucHVzaChbZnJvbUJlZm9yZSwgdG9CZWZvcmVdKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jYWNoZVB1cmVDaGFuZ2VkID0gcHVyZUNoYW5nZWQ7XG4gIH07XG5cbiAgcmV0dXJuIFJlc3VsdDtcbn0oKTtcblxuLyoqXG4gKlxuICogQG1lbWJlcm9mIGVnLkxpc3REaWZmZXJcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIC0gUHJldmlvdXMgTGlzdCA8a28+IOydtOyghCDrqqnroZ0gPC9rbz5cbiAqIEBwYXJhbSAtIExpc3QgdG8gVXBkYXRlIDxrbz4g7JeF642w7J207Yq4IO2VoCDrqqnroZ0gPC9rbz5cbiAqIEBwYXJhbSAtIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyB0aGUga2V5IG9mIHRoZSBpdGVtLiA8a28+IOyVhOydtO2FnOydmCDtgqTrpbwg67CY7ZmY7ZWY64qUIOy9nOuwsSDtlajsiJjsnoXri4jri6QuPC9rbz5cbiAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBkaWZmIGJldHdlZW4gYHByZXZMaXN0YCBhbmQgYGxpc3RgIDxrbz4gYHByZXZMaXN0YOyZgCBgbGlzdGDsnZgg64uk66W4IOygkOydhCDrsJjtmZjtlZzri6QuPC9rbz5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBkaWZmIH0gZnJvbSBcIkBlZ2pzL2xpc3QtZGlmZmVyXCI7XG4gKiAvLyBzY3JpcHQgPT4gZWcuTGlzdERpZmZlci5kaWZmXG4gKiBjb25zdCByZXN1bHQgPSBkaWZmKFswLCAxLCAyLCAzLCA0LCA1XSwgWzcsIDgsIDAsIDQsIDMsIDYsIDIsIDFdLCBlID0+IGUpO1xuICogLy8gTGlzdCBiZWZvcmUgdXBkYXRlXG4gKiAvLyBbMSwgMiwgMywgNCwgNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5wcmV2TGlzdCk7XG4gKiAvLyBVcGRhdGVkIGxpc3RcbiAqIC8vIFs0LCAzLCA2LCAyLCAxXVxuICogY29uc29sZS5sb2cocmVzdWx0Lmxpc3QpO1xuICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIGFkZGVkIHRvIGBsaXN0YFxuICogLy8gWzAsIDEsIDVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuYWRkZWQpO1xuICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIHJlbW92ZWQgaW4gYHByZXZMaXN0YFxuICogLy8gWzVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucmVtb3ZlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgd2l0aCBkaWZmZXJlbnQgaW5kZXhlcyBmcm9tIGBwcmV2TGlzdGAgYW5kIGBsaXN0YFxuICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICogY29uc29sZS5sb2cocmVzdWx0LmNoYW5nZWQpO1xuICogLy8gVGhlIHN1YnNldCBvZiBgY2hhbmdlZGAgYW5kIGFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRoYXQgbW92ZWQgZGF0YSBkaXJlY3RseS4gSW5kaWNhdGUgYW4gYXJyYXkgb2YgYWJzb2x1dGUgaW5kZXggcGFpcnMgb2YgYG9yZGVyZWRgLihGb3JtYXR0ZWQgYnk6IEFycmF5PFtpbmRleCBvZiBwcmV2TGlzdCwgaW5kZXggb2YgbGlzdF0+KVxuICogLy8gW1s0LCAzXSwgWzMsIDRdLCBbMiwgNl1dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucHVyZUNoYW5nZWQpO1xuICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdG8gYmUgYG9yZGVyZWRgIHRoYXQgY2FuIHN5bmNocm9uaXplIGBsaXN0YCBiZWZvcmUgYWRkaW5nIGRhdGEuIChGb3JtYXR0ZWQgYnk6IEFycmF5PFtwcmV2SW5kZXgsIG5leHRJbmRleF0+KVxuICogLy8gW1s0LCAxXSwgWzQsIDJdLCBbNCwgM11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQub3JkZXJlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgdGhhdCBoYXZlIG5vdCBiZWVuIGFkZGVkL3JlbW92ZWQgc28gZGF0YSBpcyBwcmVzZXJ2ZWRcbiAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5tYWludGFpbmVkKTtcbiAqL1xuXG5mdW5jdGlvbiBkaWZmKHByZXZMaXN0LCBsaXN0LCBmaW5kS2V5Q2FsbGJhY2spIHtcbiAgdmFyIG1hcENsYXNzID0gU1VQUE9SVF9NQVAgPyBNYXAgOiBmaW5kS2V5Q2FsbGJhY2sgPyBIYXNoTWFwIDogUG9seU1hcDtcblxuICB2YXIgY2FsbGJhY2sgPSBmaW5kS2V5Q2FsbGJhY2sgfHwgZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfTtcblxuICB2YXIgYWRkZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgdmFyIG1haW50YWluZWQgPSBbXTtcbiAgdmFyIHByZXZLZXlzID0gcHJldkxpc3QubWFwKGNhbGxiYWNrKTtcbiAgdmFyIGtleXMgPSBsaXN0Lm1hcChjYWxsYmFjayk7XG4gIHZhciBwcmV2S2V5TWFwID0gbmV3IG1hcENsYXNzKCk7XG4gIHZhciBrZXlNYXAgPSBuZXcgbWFwQ2xhc3MoKTtcbiAgdmFyIGNoYW5nZWRCZWZvcmVBZGRlZCA9IFtdO1xuICB2YXIgZml4ZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWRNYXAgPSB7fTtcbiAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgdmFyIGFkZGVkQ291bnQgPSAwO1xuICB2YXIgcmVtb3ZlZENvdW50ID0gMDsgLy8gQWRkIHByZXZLZXlzIGFuZCBrZXlzIHRvIHRoZSBoYXNobWFwLlxuXG4gIHByZXZLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgcHJldkxpc3RJbmRleCkge1xuICAgIHByZXZLZXlNYXAuc2V0KGtleSwgcHJldkxpc3RJbmRleCk7XG4gIH0pO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgbGlzdEluZGV4KSB7XG4gICAga2V5TWFwLnNldChrZXksIGxpc3RJbmRleCk7XG4gIH0pOyAvLyBDb21wYXJlIGBwcmV2S2V5c2AgYW5kIGBrZXlzYCBhbmQgYWRkIHRoZW0gdG8gYHJlbW92ZWRgIGlmIHRoZXkgYXJlIG5vdCBpbiBga2V5c2AuXG5cbiAgcHJldktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBwcmV2TGlzdEluZGV4KSB7XG4gICAgdmFyIGxpc3RJbmRleCA9IGtleU1hcC5nZXQoa2V5KTsgLy8gSW4gcHJldkxpc3QsIGJ1dCBub3QgaW4gbGlzdCwgaXQgaXMgcmVtb3ZlZC5cblxuICAgIGlmICh0eXBlb2YgbGlzdEluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICArK3JlbW92ZWRDb3VudDtcbiAgICAgIHJlbW92ZWQucHVzaChwcmV2TGlzdEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlZE1hcFtsaXN0SW5kZXhdID0gcmVtb3ZlZENvdW50O1xuICAgIH1cbiAgfSk7IC8vIENvbXBhcmUgYHByZXZLZXlzYCBhbmQgYGtleXNgIGFuZCBhZGQgdGhlbSB0byBgYWRkZWRgIGlmIHRoZXkgYXJlIG5vdCBpbiBgcHJldktleXNgLlxuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBsaXN0SW5kZXgpIHtcbiAgICB2YXIgcHJldkxpc3RJbmRleCA9IHByZXZLZXlNYXAuZ2V0KGtleSk7IC8vIEluIGxpc3QsIGJ1dCBub3QgaW4gcHJldkxpc3QsIGl0IGlzIGFkZGVkLlxuXG4gICAgaWYgKHR5cGVvZiBwcmV2TGlzdEluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBhZGRlZC5wdXNoKGxpc3RJbmRleCk7XG4gICAgICArK2FkZGVkQ291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1haW50YWluZWQucHVzaChbcHJldkxpc3RJbmRleCwgbGlzdEluZGV4XSk7XG4gICAgICByZW1vdmVkQ291bnQgPSByZW1vdmVkTWFwW2xpc3RJbmRleF0gfHwgMDtcbiAgICAgIGNoYW5nZWRCZWZvcmVBZGRlZC5wdXNoKFtwcmV2TGlzdEluZGV4IC0gcmVtb3ZlZENvdW50LCBsaXN0SW5kZXggLSBhZGRlZENvdW50XSk7XG4gICAgICBmaXhlZC5wdXNoKGxpc3RJbmRleCA9PT0gcHJldkxpc3RJbmRleCk7XG5cbiAgICAgIGlmIChwcmV2TGlzdEluZGV4ICE9PSBsaXN0SW5kZXgpIHtcbiAgICAgICAgY2hhbmdlZC5wdXNoKFtwcmV2TGlzdEluZGV4LCBsaXN0SW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBTb3J0IGJ5IGFzY2VuZGluZyBvcmRlciBvZiAndG8obGlzdCdzIGluZGV4KS5cblxuICByZW1vdmVkLnJldmVyc2UoKTtcbiAgcmV0dXJuIG5ldyBSZXN1bHQocHJldkxpc3QsIGxpc3QsIGFkZGVkLCByZW1vdmVkLCBjaGFuZ2VkLCBtYWludGFpbmVkLCBjaGFuZ2VkQmVmb3JlQWRkZWQsIGZpeGVkKTtcbn1cblxuLyoqXG4gKiBBIG1vZHVsZSB0aGF0IGNoZWNrcyBkaWZmIHdoZW4gdmFsdWVzIGFyZSBhZGRlZCwgcmVtb3ZlZCwgb3IgY2hhbmdlZCBpbiBhbiBhcnJheS5cbiAqIEBrbyDrsLDsl7Qg65iQ64qUIOyYpOu4jOygne2KuOyXkOyEnCDqsJLsnbQg7LaU6rCA65CY6rGw64KYIOyCreygnOuQmOqxsOuCmCDsiJzshJzqsIAg67OA6rK97IKs7ZWt7J2EIOyytO2BrO2VmOuKlCDrqqjrk4jsnoXri4jri6QuXG4gKiBAbWVtYmVyb2YgZWdcbiAqL1xuXG52YXIgTGlzdERpZmZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gLSBJbml0aWFsaXppbmcgRGF0YSBBcnJheS4gPGtvPiDstIjquLAg7ISk7KCV7ZWgIOuNsOydtO2EsCDrsLDsl7QuPC9rbz5cbiAgICogQHBhcmFtIC0gVGhpcyBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGl0ZW0uIDxrbz4g7JWE7J207YWc7J2YIO2CpOulvCDrsJjtmZjtlZjripQg7L2c67CxIO2VqOyImOyeheuLiOuLpC48L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTGlzdERpZmZlciBmcm9tIFwiQGVnanMvbGlzdC1kaWZmZXJcIjtcbiAgICogLy8gc2NyaXB0ID0+IGVnLkxpc3REaWZmZXJcbiAgICogY29uc3QgZGlmZmVyID0gbmV3IExpc3REaWZmZXIoWzAsIDEsIDIsIDMsIDQsIDVdLCBlID0+IGUpO1xuICAgKiBjb25zdCByZXN1bHQgPSBkaWZmZXIudXBkYXRlKFs3LCA4LCAwLCA0LCAzLCA2LCAyLCAxXSk7XG4gICAqIC8vIExpc3QgYmVmb3JlIHVwZGF0ZVxuICAgKiAvLyBbMSwgMiwgMywgNCwgNV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnByZXZMaXN0KTtcbiAgICogLy8gVXBkYXRlZCBsaXN0XG4gICAqIC8vIFs0LCAzLCA2LCAyLCAxXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQubGlzdCk7XG4gICAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyBhZGRlZCB0byBgbGlzdGAuXG4gICAqIC8vIFswLCAxLCA1XVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQuYWRkZWQpO1xuICAgKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgcmVtb3ZlZCBpbiBgcHJldkxpc3RgLlxuICAgKiAvLyBbNV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnJlbW92ZWQpO1xuICAgKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgd2l0aCBkaWZmZXJlbnQgaW5kZXhlcyBmcm9tIGBwcmV2TGlzdGAgYW5kIGBsaXN0YC5cbiAgICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQuY2hhbmdlZCk7XG4gICAqIC8vIFRoZSBzdWJzZXQgb2YgYGNoYW5nZWRgIGFuZCBhbiBhcnJheSBvZiBpbmRleCBwYWlycyB0aGF0IG1vdmVkIGRhdGEgZGlyZWN0bHkuIEluZGljYXRlIGFuIGFycmF5IG9mIGFic29sdXRlIGluZGV4IHBhaXJzIG9mIGBvcmRlcmVkYC4oRm9ybWF0dGVkIGJ5OiBBcnJheTxbaW5kZXggb2YgcHJldkxpc3QsIGluZGV4IG9mIGxpc3RdPilcbiAgICogLy8gW1s0LCAzXSwgWzMsIDRdLCBbMiwgNl1dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5wdXJlQ2hhbmdlZCk7XG4gICAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRvIGJlIGBvcmRlcmVkYCB0aGF0IGNhbiBzeW5jaHJvbml6ZSBgbGlzdGAgYmVmb3JlIGFkZGluZyBkYXRhLiAoRm9ybWF0dGVkIGJ5OiBBcnJheTxbcHJldkluZGV4LCBuZXh0SW5kZXhdPilcbiAgICogLy8gW1s0LCAxXSwgWzQsIDJdLCBbNCwgM11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5vcmRlcmVkKTtcbiAgICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHRoYXQgaGF2ZSBub3QgYmVlbiBhZGRlZC9yZW1vdmVkIHNvIGRhdGEgaXMgcHJlc2VydmVkLlxuICAgKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5tYWludGFpbmVkKTtcbiAgICovXG4gIGZ1bmN0aW9uIExpc3REaWZmZXIobGlzdCwgZmluZEtleUNhbGxiYWNrKSB7XG4gICAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgICAgbGlzdCA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuZmluZEtleUNhbGxiYWNrID0gZmluZEtleUNhbGxiYWNrO1xuICAgIHRoaXMubGlzdCA9IFtdLnNsaWNlLmNhbGwobGlzdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBsaXN0LlxuICAgKiBAa28g66as7Iqk7Yq466W8IOyXheuNsOydtO2KuOulvCDtlanri4jri6QuXG4gICAqIEBwYXJhbSAtIExpc3QgdG8gdXBkYXRlIDxrbz4g7JeF642w7J207Yq47ZWgIOumrOyKpO2KuCA8L2tvPlxuICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhbiB1cGRhdGUgZnJvbSBgcHJldkxpc3RgIHRvIGBsaXN0YC48a28+IGBwcmV2TGlzdGDsl5DshJwgYGxpc3Rg66GcIOyXheuNsOydtO2KuO2VnCDqsrDqs7zrpbwg67CY7ZmY7ZWc64ukLiA8L2tvPlxuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gTGlzdERpZmZlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by51cGRhdGUgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciBuZXdEYXRhID0gW10uc2xpY2UuY2FsbChsaXN0KTtcbiAgICB2YXIgcmVzdWx0ID0gZGlmZih0aGlzLmxpc3QsIG5ld0RhdGEsIHRoaXMuZmluZEtleUNhbGxiYWNrKTtcbiAgICB0aGlzLmxpc3QgPSBuZXdEYXRhO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIExpc3REaWZmZXI7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG5cbmV4cG9ydCBkZWZhdWx0IExpc3REaWZmZXI7XG5leHBvcnQgeyBkaWZmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LWRpZmZlci5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@egjs+list-differ@1.0.1/node_modules/@egjs/list-differ/dist/list-differ.esm.js\n");

/***/ })

};
;